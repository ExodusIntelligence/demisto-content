from collections import defaultdict
from dataclasses import dataclass

from enum import Enum

import demistomock as demisto
from CommonServerPython import *
from CommonServerUserPython import *

from typing import Dict, Any, NamedTuple
import traceback


# Investigation = NamedTuple('Investigation', (
#     ('tactic', str),
#     ('technique', str),
#     ('result', Result),
#     ('category', Category),
# ))
Tactic = NamedTuple('Tactic', (('code', str), ('description', str)))
Technique = NamedTuple('Technique', (('tactic', Tactic), ('detected', Optional[bool])))
Table = NamedTuple('Table', (('title', str), ('content', list[dict[str, str]])))


class TechniqueParser:
    def __init__(self, name: str, code: str, default_questions: Optional[tuple[Tactic]]):
        self.name = name
        self.code = code
        self.default_tactics: tuple[Tactic] = default_questions or ()

    def parse(self, context: dict) -> tuple[Technique]:
        defaults = tuple(self._search_default(question, context) for question in self.default_tactics)
        optional = self.search_optional(context)
        return defaults + optional

    def search_optional(self, context: dict) -> tuple[Technique]:
        found = []
        for attack in context.get('AttackPattern', {}):  # todo how does it look with multiple values?
            mitre_id = attack.get('MITREID')
            technique = Technique(tactic=Tactic(mitre_id, self.name), detected=True)

            if self.name in attack.get('KillChainPhases', ()):
                found.append(technique)  # todo is ok?

            elif self.code == mitre_id:
                found.append(technique)  # todo is ok?
        return tuple(found)

    @staticmethod
    def _search_default(question: Tactic, context) -> Technique:
        result = False  # default_tactics

        if question.code == context.get('AttackPattern', {}).get('MITREID'):  # todo is correct?
            demisto.debug(f'detected {question.code} in AttackPattern.MITREID')
            result = True

        elif question.code in context.get('AttackPattern', {}).get('KillChainPhases', ()):  # todo is correct?
            demisto.debug(f'detected {question.code} in AttackPattern.KillChainPhases')
            result = True

        else:
            demisto.debug(f'could not detect {question.code}')

        return Technique(question, result)

    # def results(self, context: dict) -> list[dict[str, bool]]:  # todo remove?
    #     return [{result.question.description: result.detected} for result in self._parse(context)]


class Execution(TechniqueParser):
    def __init__(self):
        super().__init__(name='Execution', code='TA0002', default_questions=(
            Tactic(code='T1059', description='Is process invoked through command interpreter or scripting?'),
        ))


class PrivilegeEscalation(TechniqueParser):
    def __init__(self):
        super().__init__(name='Privilege Escalation', code='TA0004',
                         default_questions=(Tactic(code='T1547', description='Boot or Logon Autostart Execution'),))


class LateralMovement(TechniqueParser):
    def __init__(self):
        super().__init__(name='Lateral Movement', code='TA0008',
                         default_questions=(Tactic(code='T1021', description='Remote Services'),))


class DefenseEvasion(TechniqueParser):
    def __init__(self):
        super().__init__(name='Defense Evasion', code='TA0005',
                         default_questions=(Tactic(code='T1070', description='Indicator Removal on Host'),))


class Persistence(TechniqueParser):
    def __init__(self):
        super().__init__(name='Persistence', code='TA003',
                         default_questions=(Tactic(code='T1547', description='Boot or Logon Autostart Execution'),))


def parse_command(context: dict) -> list[CommandResults]:
    tables = []
    # todo what order to show them? Alphabetical? By code? detected first?
    for parser_class in (Execution, PrivilegeEscalation, LateralMovement, DefenseEvasion, Persistence):
        instance = parser_class()
        findings = instance.parse(context)
        table = Table(instance.name,
                      # [{'name': finding.question.description,'detected': finding.detected } for finding in findings])
                      [{finding.question.description: finding.detected} for finding in findings]  # todo decide
                      )


def main():
    try:
        context = demisto.callingContext.get('context', {}).get('ExecutionContext', {})
        result = parse_command(context)
        return_results(result)
    except Exception as ex:
        demisto.error(traceback.format_exc())  # print the traceback
        return_error(f'Failed to execute InvestigationDetailedSummaryParse. Error: {str(ex)}')


if __name__ in ('__main__', '__builtin__', 'builtins'):
    main()
