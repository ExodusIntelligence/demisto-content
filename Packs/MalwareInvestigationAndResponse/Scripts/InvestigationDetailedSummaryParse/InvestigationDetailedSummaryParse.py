from collections import defaultdict
from dataclasses import dataclass

from enum import Enum

import demistomock as demisto
from CommonServerPython import *
from CommonServerUserPython import *

from typing import Dict, Any, NamedTuple
import traceback


class Result(Enum):
    SUSPICIOUS = 1
    NOT_DETECTED = 0


# Investigation = NamedTuple('Investigation', (
#     ('tactic', str),
#     ('technique', str),
#     ('result', Result),
#     ('category', Category),
# ))
Question = NamedTuple('Question', (('code', str), ('description', str)))
# Finding = NamedTuple('Finding', (('question', Question), ('result', Result))) # todo
BooleanFinding = NamedTuple('Finding', (('question', Question), ('detected', bool)))


#
# class CategoryManager:
#     execution = Category('Execution', 'TA0002')
#     privilege_escalation = Category('Privilege Escalation', 'TA0004')
#     lateral_movement = Category('Lateral Movement', 'TA0008')
#     defense_evasion = Category('Defense Evasion', 'TA0005')
#
#
# DEFAULT_CATEGORIES_TO_CHECK = tuple(
#     ()
# )


class DetailedParser:
    def __init__(self, name: str, code: str, context: dict, default_questions: Optional[tuple[Question]],
                 optional_questions: Optional[tuple[Question]]):
        self.context = context
        self.name = name
        self.code = code
        self.default_questions: tuple[Question] = tuple(default_questions) or ()
        self.optional_questions: tuple[Question] = tuple(optional_questions) or ()

    def _parse(self) -> tuple[BooleanFinding]:
        return tuple(self._parse_single_boolean(question)
                     for question in self.default_questions + self.optional_questions)

    # def _parse_single(self, question: Question) -> Finding:
    #     result = Result.NOT_DETECTED  # default_questions
    #
    #     if question.code == self.context.get('AttackPattern', {}).get('MITREID'):
    #         demisto.debug(f'detected {question.code} in AttackPattern.MITREID')
    #         result = Result.SUSPICIOUS
    #
    #     elif question.code in self.context.get('AttackPattern', {}).get('KillChainPhases', ()):
    #         demisto.debug(f'detected {question.code} in AttackPattern.KillChainPhases')
    #         result = Result.SUSPICIOUS
    #
    #     else:
    #         demisto.debug(f'could not detect {question.code}')
    #
    #     return Finding(question, result)

    def _parse_single_boolean(self, question: Question) -> BooleanFinding:
        result = False  # default_questions

        if question.code == self.context.get('AttackPattern', {}).get('MITREID'):  # todo is correct?
            demisto.debug(f'detected {question.code} in AttackPattern.MITREID')
            result = True

        elif question.code in self.context.get('AttackPattern', {}).get('KillChainPhases', ()):  # todo is correct?
            demisto.debug(f'detected {question.code} in AttackPattern.KillChainPhases')
            result = True

        else:
            demisto.debug(f'could not detect {question.code}')

        return BooleanFinding(question, result)

    def to_command_result(self):
        parse_result = self._parse()
        outputs = [{result.question.description, result.detected} for result in parse_result]

        readable = tableToMarkdown('Detailed Investigation Result', t=outputs, headers=['Investigation', 'Result'])
        return CommandResults(outputs_prefix='InvestigationDetailedSummary', outputs_key_field=self.name,  # todo key
                              outputs=outputs, readable_output=readable)


class Execution(DetailedParser):
    def __init__(self, context: dict):
        super().__init__(
            name='Execution', code='TA0002', context=context,
            default_questions=(
                Question(code='T1059', description='Is process invoked through command interpreter or scripting?'),
            ),
            optional_questions=None
        )


class PrivilegeEscalation(DetailedParser):
    def __init__(self, context: dict):
        super().__init__(
            name='Privilege Escalation', code='TA0004', context=context,
            default_questions=(Question(code='T1547', description='Boot or Logon Autostart Execution'),),
            optional_questions=None
        )


class LateralMovement(DetailedParser):
    def __init__(self, context: dict):
        super().__init__(
            name='Lateral Movement', code='TA0008', context=context,
            default_questions=(Question(code='T1021', description='Remote Services'),),
            optional_questions=None
        )


class DefenseEvasion(DetailedParser):
    def __init__(self, context: dict):
        super().__init__(
            name='Defense Evasion', code='TA0005', context=context,
            default_questions=(Question(code='T1070', description='Indicator Removal on Host'),),
            optional_questions=None
        )


class Persistence(DetailedParser):
    def __init__(self, context: dict):
        super().__init__(
            name='Persistence',
            code='TA003',
            context=context,
            default_questions=(Question(code='T1547', description='Boot or Logon Autostart Execution'),),  # todo dupe?
            optional_questions=None
        )


def parse_command(context: dict) -> list[CommandResults]:


def main():
    try:
        context = demisto.callingContext.get('context', {}).get('ExecutionContext', {})
        result = parse_command(context)
        return_results(result)
    except Exception as ex:
        demisto.error(traceback.format_exc())  # print the traceback
        return_error(f'Failed to execute InvestigationDetailedSummaryParse. Error: {str(ex)}')


if __name__ in ('__main__', '__builtin__', 'builtins'):
    main()
