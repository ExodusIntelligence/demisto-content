from collections import defaultdict
from dataclasses import dataclass

from enum import Enum

import demistomock as demisto
from CommonServerPython import *
from CommonServerUserPython import *

from typing import Dict, Any, NamedTuple
import traceback


class Result(Enum):
    SUSPICIOUS = 1
    NOT_DETECTED = 0


# Investigation = NamedTuple('Investigation', (
#     ('tactic', str),
#     ('technique', str),
#     ('result', Result),
#     ('category', Category),
# ))
Question = NamedTuple('Question', (('code', str), ('description', str)))
Finding = NamedTuple('Finding', (('question', Question), ('detected', bool)))



class DetailedParser:
    def __init__(self, name: str, code: str, default_questions: Optional[tuple[Question]]):
        self.name = name
        self.code = code
        self.default_questions: tuple[Question] = tuple(default_questions) or ()

    def parse(self, context: dict) -> tuple[Finding]:
        defaults = tuple(self._search_default(question, context) for question in self.default_questions)
        optional = tuple()  # todo
        return defaults + optional

    def search_optional(self, context: dict) -> tuple[Finding]:
        found = []
        for attack in context.get('AttackPattern', {}):
            mitre_id = attack.get('MITREID')
            finding = Finding(question=Question(mitre_id, self.name), detected=True)

            if self.name in attack.get('KillChainPhases', ()):
                found.append(finding)  # todo is ok?

            elif self.code == mitre_id:

                found.append(finding)  # todo is ok?
        return tuple(found)

    @staticmethod
    def _search_default(question: Question, context) -> Finding:
        result = False  # default_questions

        if question.code == context.get('AttackPattern', {}).get('MITREID'):  # todo is correct?
            demisto.debug(f'detected {question.code} in AttackPattern.MITREID')
            result = True

        elif question.code in context.get('AttackPattern', {}).get('KillChainPhases', ()):  # todo is correct?
            demisto.debug(f'detected {question.code} in AttackPattern.KillChainPhases')
            result = True

        else:
            demisto.debug(f'could not detect {question.code}')

        return Finding(question, result)

    # def to_command_result(self, context):
    #     parse_result = self._parse(context)
    #     outputs = [{result.question.description, result.detected} for result in parse_result]
    #
    #     readable = tableToMarkdown('Detailed Investigation Result', t=outputs, headers=['Investigation', 'Result'])
    #     return CommandResults(outputs_prefix='InvestigationDetailedSummary', outputs_key_field=self.name,  # todo key
    #                           outputs=outputs, readable_output=readable)


class Execution(DetailedParser):
    def __init__(self, context: dict):
        super().__init__(name='Execution', code='TA0002', default_questions=(
            Question(code='T1059', description='Is process invoked through command interpreter or scripting?'),
        ))


class PrivilegeEscalation(DetailedParser):
    def __init__(self, context: dict):
        super().__init__(name='Privilege Escalation', code='TA0004',
                         default_questions=(Question(code='T1547', description='Boot or Logon Autostart Execution'),))


class LateralMovement(DetailedParser):
    def __init__(self, context: dict):
        super().__init__(name='Lateral Movement', code='TA0008',
                         default_questions=(Question(code='T1021', description='Remote Services'),))


class DefenseEvasion(DetailedParser):
    def __init__(self, context: dict):
        super().__init__(name='Defense Evasion', code='TA0005',
                         default_questions=(Question(code='T1070', description='Indicator Removal on Host'),))


class Persistence(DetailedParser):
    def __init__(self, context: dict):
        super().__init__(name='Persistence', code='TA003',
                         default_questions=(Question(code='T1547', description='Boot or Logon Autostart Execution'),))


def parse_command(context: dict) -> list[CommandResults]:


def main():
    try:
        context = demisto.callingContext.get('context', {}).get('ExecutionContext', {})
        result = parse_command(context)
        return_results(result)
    except Exception as ex:
        demisto.error(traceback.format_exc())  # print the traceback
        return_error(f'Failed to execute InvestigationDetailedSummaryParse. Error: {str(ex)}')


if __name__ in ('__main__', '__builtin__', 'builtins'):
    main()
