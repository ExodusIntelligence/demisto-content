from collections import defaultdict
from dataclasses import dataclass, field

from typing import NamedTuple

from CommonServerPython import *

Attack = NamedTuple('Attack', (('mitre_id', str), ('kill_chain_phases', tuple[str]), ('tactic', 'str')))

Technique = NamedTuple('Technique', (('code', str), ('name', str)))
Tactic = NamedTuple('Tactic', (('code', str), ('name', str), ('default_techniques', Optional[tuple[Technique]])))
Table = NamedTuple('Table', (('title', str), ('content', list[dict[str, str]])))


@dataclass
class TacticFinding:
    tactic: Tactic
    found: set[Technique] = field(default_factory=set)
    not_found: set[Technique] = field(default_factory=set)


TACTICS = (
    Tactic('TA0002', 'Execution', default_techniques=(
        Technique('T1059', 'Is process invoked through command interpreter or scripting?'),
    )),
    Tactic('TA0004', 'PrivilegeEscalation', default_techniques=(
        Technique('T1547', 'Boot or Logon Autostart Execution'),
    )),
    Tactic('TA0008', 'LateralMovement', default_techniques=(
        Technique('T1021', 'Remote Services'),
    )),
    Tactic('TA0005', 'DefenseEvasion', default_techniques=(
        Technique('T1070', 'Indicator Removal on Host'),
    )),
    Tactic('TA0003', 'Persistence', default_techniques=(
        Technique('T1547', 'Boot or Logon Autostart Execution'),
    )),
)


class AttackPatternParser:
    def __init__(self, context: dict):
        self.attacks: tuple[Attack] = AttackPatternParser._parse(context)

        self.mitre_id_to_attacks = defaultdict(list)
        for attack in self.attacks:
            self.mitre_id_to_attacks[attack.mitre_id].append(attack)

        self.tactic_to_attack = defaultdict(list)
        for attack in self.attacks:
            self.tactic_to_attack[attack.]

    @staticmethod
    def _parse(context: dict):
        parsed: list[Attack] = []

        attack_pattern_context = context.get('AttackPattern', ())
        if isinstance(attack_pattern_context, dict):  # can be dict or list of dicts.
            attack_pattern_context = attack_pattern_context,

        for attack_dict in attack_pattern_context:
            parsed.append(Attack(attack_dict.get('MITREID'),
                                 kill_chain_phases=tuple(attack_dict.get('KillChainPhases'))))
        return tuple(parsed)

    def find(self) -> dict[Tactic, list[Technique]]:
        result = defaultdict(list)

        for tactic in TACTICS:
            finding = TacticFinding(tactic)
            for search_technique in tactic.default_techniques:
                if search_technique.code in self.mitre_id_to_attacks:
                    finding.found.add(search_technique)
                else:
                    finding.not_found.add(search_technique)

            for attack in self.attacks:
                if attack.mitre_id == 1:  # todo
                    result[tactic]
        return tuple(techniques)


def parse_command(context: dict) -> list[CommandResults]:
    parsed_attacks = AttackPatternParser(demisto.callingContext.get('context', {}).get('ExecutionContext', {}))
    tables = []
    # todo what order to show them? Alphabetical? By code? detected first?
    for parser_class in (Execution, PrivilegeEscalation, LateralMovement, DefenseEvasion, Persistence):
        instance = parser_class()
        findings = instance.parse(context)
        table = Table(instance.name,
                      # [{'name': finding.question.description,'detected': finding.detected } for finding in findings])
                      [{finding.question.description: finding.detected} for finding in findings]  # todo decide
                      )


def main():
    try:
        result = parse_command(context)
        return_results(result)
    except Exception as ex:
        demisto.error(traceback.format_exc())  # print the traceback
        return_error(f'Failed to execute InvestigationDetailedSummaryParse. Error: {str(ex)}')


if __name__ in ('__main__', '__builtin__', 'builtins'):
    main()
